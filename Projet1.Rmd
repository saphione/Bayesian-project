---
title: "Projet1_Bayesian"
author: "Lorazo, M. De Koninck, A"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Loading packages}
library(readr)
library(R2jags)
```


```{r}
hoopoe <- read_delim("C:/Users/Saphione/OneDrive/Fac/M2/Cours/Bayésien/Projet/projet1/hoopoe.csv", delim = ";", escape_double = FALSE, trim_ws = TRUE)
hoopoe <- hoopoe[,c(1:3,5:7)]
hoopoe$ring <- as.factor(hoopoe$ring)
```

We analysed the data separately for each species, applying a hierarchical logistic regression model (with random intercept and slope parameters) implemented in a Bayesian framework using
Markov chain Monte Carlo simulation (Appendix S1). The response variable was Boolean, with a 0 value for random locations and 1 for foraging locations. 
For each dominant habitat category for hoopoe (fruit tree plantation, grassland, all remaining habitat types together) we first ran the basic model including effects of bare ground and its square, as well as vegetation height and its square. This enabled us to evaluate whether the relationships between bird occurrence and vegetation structure were consistent among broad habitat categories. We found that this was the case (Figure S1), and thus did not consider habitat categories in subsequent analyses. 

```{r Définition variables explicatives}
# %bareground
x_bg <- hoopoe$bare
hoopoe$x_bg_carr <- (x_bg)^2
# vegetation height
x_vh <- hoopoe$heightC
hoopoe$x_vh_carr <- (x_vh)^2
```

```{r Création dataset}
datahoopoe <- list(
  N = length(hoopoe$y),
  y = ifelse(hoopoe$y == "random", 0, 1),
  ring = as.numeric(hoopoe$ring),
  nb = length(levels(hoopoe$ring)),
  bare = as.numeric(scale(hoopoe$bare)),
  bare_carre = as.numeric(scale(hoopoe$x_bg_carr)),
  height = as.numeric(scale(hoopoe$heightC)),
  height_carre = as.numeric(scale(hoopoe$x_vh_carr))
)
```

```{r logisitic model complet}
logisitic <- function(){
  for(i in 1:N){
    y[i] ~ dbin(p[i],1) # binomial likelihood
    logit(p[i]) <- a[ring[i]] + b.bare[ring[i]] * bare[i] + b.bare_carre[ring[i]] * bare_carre[i] + b.height[ring[i]] * height[i] + b.height_carre[ring[i]] * height_carre[i]
  }
  for (j in 1:nb){
    a[j] ~ dnorm(mua,tau.a) 
    b.bare[j] ~ dnorm(mubare,tau.b)
    b.bare_carre[j] ~ dnorm(mubarec,tau.bc)
    b.height[j] ~ dnorm(muheight,tau.v)
    b.height_carre[j] ~ dnorm(muheightc,tau.vc) 
  }
mua ~ dnorm(0,0.001) 
mubare ~ dnorm(0,0.001) 
mubarec ~ dnorm(0,0.001) 
muheight ~ dnorm(0,0.001)
muheightc ~ dnorm(0,0.001)
tau.a <- 1 / (sigma.a * sigma.a)
sigma.a ~ dunif(0,100)
tau.b <- 1 / (sigma.b * sigma.b)
sigma.b ~ dunif(0,100)
tau.bc <- 1 / (sigma.bc * sigma.bc)
sigma.bc ~ dunif(0,100)
tau.v <- 1 / (sigma.v * sigma.v)
sigma.v ~ dunif(0,100)
tau.vc <- 1 / (sigma.vc * sigma.vc)
sigma.vc ~ dunif(0,100)
}

# initial values
init1 <- list(a = rep(0.5, datahoopoe$nb), b.bare = rep(1, datahoopoe$nb), b.bare_carre = rep(1, datahoopoe$nb), b.height = rep(1, datahoopoe$nb), b.height_carre = rep(1, datahoopoe$nb))
init2 <- list(a = rep(-0.5, datahoopoe$nb), b.bare = rep(-1, datahoopoe$nb), b.bare_carre = rep(-1, datahoopoe$nb), b.height = rep(-1, datahoopoe$nb), b.height_carre = rep(-1, datahoopoe$nb))
init3 <- list(a = rep(0, datahoopoe$nb), b.bare = rep(0, datahoopoe$nb), b.bare_carre = rep(0, datahoopoe$nb), b.height = rep(0, datahoopoe$nb), b.height_carre = rep(0, datahoopoe$nb))
init4 <- list(a = rep(-1, datahoopoe$nb), b.bare = rep(-1, datahoopoe$nb), b.bare_carre = rep(-1, datahoopoe$nb), b.height = rep(-1, datahoopoe$nb), b.height_carre = rep(-1, datahoopoe$nb))
init5 <- list(a = rep(1, datahoopoe$nb), b.bare = rep(1, datahoopoe$nb), b.bare_carre = rep(1, datahoopoe$nb), b.height = rep(1, datahoopoe$nb), b.height_carre = rep(1, datahoopoe$nb))
init <- list(init1, init2, init3, init4, init5)

# parameters to monitor , 
params <- c("a","b.bare", "b.bare_carre", "b.height", "b.height_carre")
# call jags to fit model
partial_pooling_fit <- jags(data = datahoopoe,
                             inits = init,
                             parameters.to.save = params,
                             model.file = logisitic,
                             n.chains = 5,
                             n.iter = 60000,
                             n.burnin = 15000,
                             n.thin = 1)
partial_pooling_fit
par(mfrow = c(1, 2))
hist(partial_pooling_fit$BUGSoutput$sims.matrix)
plot(density(partial_pooling_fit$BUGSoutput$sims.matrix))
```


```{r}
traceplot(partial_pooling_fit)
```

Second, we fitted different models that included different combinations of effects of bare ground and its square, as well as vegetation height and its square. The models were then ranked according to the deviance information criterion (DIC, [26]). Squared effects were included because of a likely trade-off between food abundance and accessibility on the one hand, and vegetation density and height on the other, which would result in curvilinear
relationships peaking at intermediate values of predictor variables. Based on the best models we calculated predictive distributions to evaluate goodness-of-fit. We compared observed values with predicted values using x2-diagnostics and report Bayesian Pvalues. 



